// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: domains.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const domainsCreate = `-- name: DomainsCreate :one
INSERT INTO domains (tenant_id, name, domain_type, source, status)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (tenant_id, name)
    DO UPDATE SET updated_at = NOW()
RETURNING id, uid, name, domain_type, source, status, created_at, updated_at
`

type DomainsCreateParams struct {
	TenantID   pgtype.Int4  `json:"tenant_id"`
	Name       string       `json:"name"`
	DomainType DomainType   `json:"domain_type"`
	Source     DomainSource `json:"source"`
	Status     DomainStatus `json:"status"`
}

type DomainsCreateRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Create a new domain (no auth)
func (q *Queries) DomainsCreate(ctx context.Context, arg DomainsCreateParams) (DomainsCreateRow, error) {
	row := q.db.QueryRow(ctx, domainsCreate,
		arg.TenantID,
		arg.Name,
		arg.DomainType,
		arg.Source,
		arg.Status,
	)
	var i DomainsCreateRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsDeleteByID = `-- name: DomainsDeleteByID :one
DELETE
FROM domains
WHERE uid = $1
RETURNING id, uid, tenant_id, name, domain_type, source, status, created_at, updated_at
`

type DomainsDeleteByIDRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Delete a domain (no auth)
func (q *Queries) DomainsDeleteByID(ctx context.Context, uid string) (DomainsDeleteByIDRow, error) {
	row := q.db.QueryRow(ctx, domainsDeleteByID, uid)
	var i DomainsDeleteByIDRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsDeleteCount = `-- name: DomainsDeleteCount :one
WITH RECURSIVE domain_tree AS (
    -- Base case: the domain we're deleting
    SELECT d.id, d.uid, d.name
    FROM domains d
    WHERE d.uid = $1

    UNION ALL

    -- Recursive case: all child domains
    SELECT d.id, d.uid, d.name
    FROM domains d
             JOIN domain_tree dt ON d.parent_domain_id = dt.id)
SELECT COUNT(*)
FROM domain_tree
`

func (q *Queries) DomainsDeleteCount(ctx context.Context, uid string) (int64, error) {
	row := q.db.QueryRow(ctx, domainsDeleteCount, uid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const domainsGetAllRecordsByTenantID = `-- name: DomainsGetAllRecordsByTenantID :many
SELECT d.name,
       a.ipv4_address,
       aaaa.ipv6_address,
       mx.preference      AS mx_pref,
       mx.target          AS mx_target,
       txt.value          AS txt_record,
       ptr.target         AS ptr_target,
       cname.target       AS cname_target,
       ns.nameserver,
       soa.nameserver     AS soa_nameserver,
       soa.email          AS soa_email,
       soa.serial         AS soa_serial,
       soa.refresh        AS soa_refresh,
       soa.retry          AS soa_retry,
       soa.expire         AS soa_expire,
       soa.minimum_ttl    AS soa_minimum_ttl,
       srv.target         AS srv_target,
       srv.port           AS srv_port,
       srv.weight         AS srv_weight,
       srv.priority       AS srv_priority,
       caa.flags          AS caa_flags,
       caa.tag            AS caa_tag,
       caa.value          AS caa_value,
       dnskey.public_key  AS dnskey_public_key,
       dnskey.flags       AS dnskey_flags,
       dnskey.protocol    AS dnskey_protocol,
       dnskey.algorithm   AS dnskey_algorithm,
       ds.key_tag         AS ds_keytag,
       ds.algorithm       AS ds_algorithm,
       ds.digest_type     AS ds_digest_type,
       ds.digest          AS ds_digest,
       rrsig.type_covered AS rrsig_type_covered,
       rrsig.algorithm    AS rrsig_algorithm,
       rrsig.labels       AS rrsig_labels,
       rrsig.original_ttl AS rrsig_original_ttl,
       rrsig.expiration   AS rrsig_expiration,
       rrsig.inception    AS rrsig_inception,
       rrsig.key_tag      AS rrsig_keytag,
       rrsig.signer_name  AS rrsig_signer_name,
       rrsig.signature    AS rrsig_signature
FROM domains d
         LEFT JOIN a_records a ON d.id = a.domain_id
         LEFT JOIN aaaa_records aaaa ON d.id = aaaa.domain_id
         LEFT JOIN mx_records mx ON d.id = mx.domain_id
         LEFT JOIN txt_records txt ON d.id = txt.domain_id
         LEFT JOIN ptr_records ptr ON d.id = ptr.domain_id
         LEFT JOIN cname_records cname ON d.id = cname.domain_id
         LEFT JOIN ns_records ns ON d.id = ns.domain_id
         LEFT JOIN soa_records soa ON d.id = soa.domain_id
         LEFT JOIN srv_records srv ON d.id = srv.domain_id
         LEFT JOIN caa_records caa ON d.id = caa.domain_id
         LEFT JOIN dnskey_records dnskey ON d.id = dnskey.domain_id
         LEFT JOIN ds_records ds ON d.id = ds.domain_id
         LEFT JOIN rrsig_records rrsig ON d.id = rrsig.domain_id
WHERE d.tenant_id = $1
ORDER BY d.name ASC
LIMIT $2 OFFSET $3
`

type DomainsGetAllRecordsByTenantIDParams struct {
	TenantID pgtype.Int4 `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type DomainsGetAllRecordsByTenantIDRow struct {
	Name             string      `json:"name"`
	Ipv4Address      pgtype.Text `json:"ipv4_address"`
	Ipv6Address      pgtype.Text `json:"ipv6_address"`
	MxPref           pgtype.Int4 `json:"mx_pref"`
	MxTarget         pgtype.Text `json:"mx_target"`
	TxtRecord        pgtype.Text `json:"txt_record"`
	PtrTarget        pgtype.Text `json:"ptr_target"`
	CnameTarget      pgtype.Text `json:"cname_target"`
	Nameserver       pgtype.Text `json:"nameserver"`
	SoaNameserver    pgtype.Text `json:"soa_nameserver"`
	SoaEmail         pgtype.Text `json:"soa_email"`
	SoaSerial        pgtype.Int8 `json:"soa_serial"`
	SoaRefresh       pgtype.Int4 `json:"soa_refresh"`
	SoaRetry         pgtype.Int4 `json:"soa_retry"`
	SoaExpire        pgtype.Int4 `json:"soa_expire"`
	SoaMinimumTtl    pgtype.Int4 `json:"soa_minimum_ttl"`
	SrvTarget        pgtype.Text `json:"srv_target"`
	SrvPort          pgtype.Int4 `json:"srv_port"`
	SrvWeight        pgtype.Int4 `json:"srv_weight"`
	SrvPriority      pgtype.Int4 `json:"srv_priority"`
	CaaFlags         pgtype.Int4 `json:"caa_flags"`
	CaaTag           pgtype.Text `json:"caa_tag"`
	CaaValue         pgtype.Text `json:"caa_value"`
	DnskeyPublicKey  pgtype.Text `json:"dnskey_public_key"`
	DnskeyFlags      pgtype.Int4 `json:"dnskey_flags"`
	DnskeyProtocol   pgtype.Int4 `json:"dnskey_protocol"`
	DnskeyAlgorithm  pgtype.Int4 `json:"dnskey_algorithm"`
	DsKeytag         pgtype.Int4 `json:"ds_keytag"`
	DsAlgorithm      pgtype.Int4 `json:"ds_algorithm"`
	DsDigestType     pgtype.Int4 `json:"ds_digest_type"`
	DsDigest         pgtype.Text `json:"ds_digest"`
	RrsigTypeCovered pgtype.Int4 `json:"rrsig_type_covered"`
	RrsigAlgorithm   pgtype.Int4 `json:"rrsig_algorithm"`
	RrsigLabels      pgtype.Int4 `json:"rrsig_labels"`
	RrsigOriginalTtl pgtype.Int4 `json:"rrsig_original_ttl"`
	RrsigExpiration  pgtype.Int4 `json:"rrsig_expiration"`
	RrsigInception   pgtype.Int4 `json:"rrsig_inception"`
	RrsigKeytag      pgtype.Int4 `json:"rrsig_keytag"`
	RrsigSignerName  pgtype.Text `json:"rrsig_signer_name"`
	RrsigSignature   pgtype.Text `json:"rrsig_signature"`
}

// Get domains with all their DNS records
// todo: develop only; reconsider need for this
func (q *Queries) DomainsGetAllRecordsByTenantID(ctx context.Context, arg DomainsGetAllRecordsByTenantIDParams) ([]DomainsGetAllRecordsByTenantIDRow, error) {
	rows, err := q.db.Query(ctx, domainsGetAllRecordsByTenantID, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainsGetAllRecordsByTenantIDRow{}
	for rows.Next() {
		var i DomainsGetAllRecordsByTenantIDRow
		if err := rows.Scan(
			&i.Name,
			&i.Ipv4Address,
			&i.Ipv6Address,
			&i.MxPref,
			&i.MxTarget,
			&i.TxtRecord,
			&i.PtrTarget,
			&i.CnameTarget,
			&i.Nameserver,
			&i.SoaNameserver,
			&i.SoaEmail,
			&i.SoaSerial,
			&i.SoaRefresh,
			&i.SoaRetry,
			&i.SoaExpire,
			&i.SoaMinimumTtl,
			&i.SrvTarget,
			&i.SrvPort,
			&i.SrvWeight,
			&i.SrvPriority,
			&i.CaaFlags,
			&i.CaaTag,
			&i.CaaValue,
			&i.DnskeyPublicKey,
			&i.DnskeyFlags,
			&i.DnskeyProtocol,
			&i.DnskeyAlgorithm,
			&i.DsKeytag,
			&i.DsAlgorithm,
			&i.DsDigestType,
			&i.DsDigest,
			&i.RrsigTypeCovered,
			&i.RrsigAlgorithm,
			&i.RrsigLabels,
			&i.RrsigOriginalTtl,
			&i.RrsigExpiration,
			&i.RrsigInception,
			&i.RrsigKeytag,
			&i.RrsigSignerName,
			&i.RrsigSignature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsGetByID = `-- name: DomainsGetByID :one
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
WHERE uid = $1
`

type DomainsGetByIDRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) DomainsGetByID(ctx context.Context, uid string) (DomainsGetByIDRow, error) {
	row := q.db.QueryRow(ctx, domainsGetByID, uid)
	var i DomainsGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsGetByIdentifier = `-- name: DomainsGetByIdentifier :one
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
WHERE tenant_id = $1
  AND (id = $2 OR uid = $3 OR name = $4)
LIMIT 1
`

type DomainsGetByIdentifierParams struct {
	TenantID pgtype.Int4 `json:"tenant_id"`
	ID       int32       `json:"id"`
	Uid      string      `json:"uid"`
	Name     string      `json:"name"`
}

type DomainsGetByIdentifierRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Read a domain by ID, UID, or name and tenant ID (no auth)
func (q *Queries) DomainsGetByIdentifier(ctx context.Context, arg DomainsGetByIdentifierParams) (DomainsGetByIdentifierRow, error) {
	row := q.db.QueryRow(ctx, domainsGetByIdentifier,
		arg.TenantID,
		arg.ID,
		arg.Uid,
		arg.Name,
	)
	var i DomainsGetByIdentifierRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsGetByName = `-- name: DomainsGetByName :one
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
WHERE tenant_id = $1
  AND name = $2
`

type DomainsGetByNameParams struct {
	TenantID pgtype.Int4 `json:"tenant_id"`
	Name     string      `json:"name"`
}

type DomainsGetByNameRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Read a domain by name and tenant ID (no auth)
func (q *Queries) DomainsGetByName(ctx context.Context, arg DomainsGetByNameParams) (DomainsGetByNameRow, error) {
	row := q.db.QueryRow(ctx, domainsGetByName, arg.TenantID, arg.Name)
	var i DomainsGetByNameRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsListAll = `-- name: DomainsListAll :many
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
ORDER BY created_at DESC
`

type DomainsListAllRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// fixme: List all domains (no auth, for development/debugging only - avoid in production)
func (q *Queries) DomainsListAll(ctx context.Context) ([]DomainsListAllRow, error) {
	rows, err := q.db.Query(ctx, domainsListAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainsListAllRow{}
	for rows.Next() {
		var i DomainsListAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.TenantID,
			&i.Name,
			&i.DomainType,
			&i.Source,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsListByTenantID = `-- name: DomainsListByTenantID :many
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at,
       count(*) OVER () AS total_count
FROM domains
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type DomainsListByTenantIDParams struct {
	TenantID pgtype.Int4 `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type DomainsListByTenantIDRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	TotalCount int64              `json:"total_count"`
}

// List all domains for a tenant with pagination (no auth)
func (q *Queries) DomainsListByTenantID(ctx context.Context, arg DomainsListByTenantIDParams) ([]DomainsListByTenantIDRow, error) {
	rows, err := q.db.Query(ctx, domainsListByTenantID, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainsListByTenantIDRow{}
	for rows.Next() {
		var i DomainsListByTenantIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.TenantID,
			&i.Name,
			&i.DomainType,
			&i.Source,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsSearchByName = `-- name: DomainsSearchByName :many
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at,
       count(*) OVER () AS total_count
FROM domains
WHERE tenant_id = $1
  AND name ILIKE $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type DomainsSearchByNameParams struct {
	TenantID pgtype.Int4 `json:"tenant_id"`
	Name     string      `json:"name"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type DomainsSearchByNameRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	TotalCount int64              `json:"total_count"`
}

func (q *Queries) DomainsSearchByName(ctx context.Context, arg DomainsSearchByNameParams) ([]DomainsSearchByNameRow, error) {
	rows, err := q.db.Query(ctx, domainsSearchByName,
		arg.TenantID,
		arg.Name,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainsSearchByNameRow{}
	for rows.Next() {
		var i DomainsSearchByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.TenantID,
			&i.Name,
			&i.DomainType,
			&i.Source,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsUpdateByID = `-- name: DomainsUpdateByID :one
UPDATE domains
SET status      = $2,
    domain_type = $3,
    source      = $4
WHERE uid = $1
RETURNING id, uid, tenant_id, name, domain_type, source, status, created_at, updated_at
`

type DomainsUpdateByIDParams struct {
	Uid        string       `json:"uid"`
	Status     DomainStatus `json:"status"`
	DomainType DomainType   `json:"domain_type"`
	Source     DomainSource `json:"source"`
}

type DomainsUpdateByIDRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Update a domain's status (no auth)
func (q *Queries) DomainsUpdateByID(ctx context.Context, arg DomainsUpdateByIDParams) (DomainsUpdateByIDRow, error) {
	row := q.db.QueryRow(ctx, domainsUpdateByID,
		arg.Uid,
		arg.Status,
		arg.DomainType,
		arg.Source,
	)
	var i DomainsUpdateByIDRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsUpdateByIDTypeSource = `-- name: DomainsUpdateByIDTypeSource :one
UPDATE domains
SET domain_type = $2,
    source      = $3
WHERE uid = $1
RETURNING id, uid, tenant_id, name, domain_type, source, status, created_at, updated_at
`

type DomainsUpdateByIDTypeSourceParams struct {
	Uid        string       `json:"uid"`
	DomainType DomainType   `json:"domain_type"`
	Source     DomainSource `json:"source"`
}

type DomainsUpdateByIDTypeSourceRow struct {
	ID         int32              `json:"id"`
	Uid        string             `json:"uid"`
	TenantID   pgtype.Int4        `json:"tenant_id"`
	Name       string             `json:"name"`
	DomainType DomainType         `json:"domain_type"`
	Source     DomainSource       `json:"source"`
	Status     DomainStatus       `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Update a domain's type and source (no auth)
func (q *Queries) DomainsUpdateByIDTypeSource(ctx context.Context, arg DomainsUpdateByIDTypeSourceParams) (DomainsUpdateByIDTypeSourceRow, error) {
	row := q.db.QueryRow(ctx, domainsUpdateByIDTypeSource, arg.Uid, arg.DomainType, arg.Source)
	var i DomainsUpdateByIDTypeSourceRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
